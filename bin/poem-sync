#!/usr/bin/python

# Copyright (c) 2013 GRNET S.A., SRCE, IN2P3 CNRS Computing Centre
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the
# License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#
# The views and conclusions contained in the software and
# documentation are those of the authors and should not be
# interpreted as representing official policies, either expressed
# or implied, of either GRNET S.A., SRCE or IN2P3 CNRS Computing
# Centre
#
# The work represented by this source file is partially funded by
# the EGI-InSPIRE project through the European Commission's 7th
# Framework Programme (contract # INFSO-RI-261323)

import urllib
import urllib2
import os
import json
import datetime
import httplib
import sys
import urlparse
import pprint
import ConfigParser
import avro.schema
from avro.datafile import DataFileWriter
from avro.io import DatumWriter

defaultConfig = '/etc/ar-sync/poem-sync.conf'

readers = ['poem']
writers = ['file', 'avro']

##############################
# create output filename
##############################
def createOutputFilename(directory, fileTemplate, timestamp):
    return directory + '/' + (fileTemplate % timestamp)

def loadCustomerConfiguration():
    customers, customerjobs, jobsinconf, profiles  = [], [], [], []
    configFile, customerConfigFile = (None, None)
    outputdir = ''
    if os.path.isfile(defaultConfig):
        configFile = open(defaultConfig, 'r')
        for line in configFile:
            if line[0] != '#' and 'poemCustomerFile' in line:
                customerConfigFile = line.split('=', 1)[1].strip()
                customerConfigFile = customerConfigFile.strip("'")

    if customerConfigFile:
        try:
            config = ConfigParser.ConfigParser()
            config.read(customerConfigFile)

            for section in config.sections():
                if section.startswith('CUSTOMER'):
                    if config.has_option(section, 'Jobs'):
                        customerjobs = config.get(section, 'Jobs').split(',')
                        customerjobs = [job.strip() for job in customerjobs]
                        customers.append({section : customerjobs})
                elif section.startswith('JOB'):
                    if config.has_option(section, 'Profiles'):
                        profiles = config.get(section, 'Profiles').split(',')
                        profiles = [profile.strip() for profile in profiles]
                        jobsinconf.append({section : {"PROFILE" : profiles}})
                elif section == 'DIR':
                    if config.has_option(section, 'OutputDir'):
                        outputdir = config.get(section, 'OutputDir')

            for cus in customers:
                for key, value in cus.items():
                    for v in value:
                        for job in jobsinconf:
                            if v in job:
                                cus[key][value.index(v)] = jobsinconf[jobsinconf.index(job)]

        except ConfigParser.MissingSectionHeaderError as e:
            print e.filename + " is not a valid configuration file"
            print e.message
            sys.exit(1)
    else:
        return None, None

    return customers, outputdir

##############################
# load config
##############################
def loadConfiguration():
    #load config
    configFile = None
    configFields = dict()
    if os.path.isfile(defaultConfig):
        configFile = open(defaultConfig, 'r')
        lines = configFile.readlines()

        for line in lines:
            if line[0] == '#':
                continue
            splitLine = line.split('=', 1)
            if len(splitLine) > 1:
                key = splitLine[0].strip()
                value = splitLine[1].strip()
                value = value.decode('string_escape')
                if value[0] == "'":
                    if value [-1] == "'":
                        value = value[1:-1]
                    else:
                        continue
                elif value[0] == '"':
                    if value [-1] == '"':
                        value = value[1:-1]
                    else:
                        continue
                else:
                    value = int(value)
                configFields[key] = value

        configFile.close()

    return configFields

##############################
# redirect resolve
##############################
def resolve_http_redirect(url, hostKey, hostCert,  depth=0):
    if depth > 10:
        raise Exception("Redirected "+depth+" times, giving up.")

    o = urlparse.urlparse(url,allow_fragments=True)
    conn = httplib.HTTPSConnection(o.netloc, 443, hostKey, hostCert)
    path = o.path
    if o.query:
        path +='?'+o.query

    try:
        conn.request("HEAD", path)
        res = conn.getresponse()
        headers = dict(res.getheaders())
        if headers.has_key('location') and headers['location'] != url:
            return resolve_http_redirect(headers['location'], hostKey, hostCert, depth+1)
        else:
            return url
    except:
        return url;

##############################
# readers
##############################
class ProfileReader(object):

    def loadConfiguration(self, configFields):
        """Loading config"""

    def getProfiles(self):
        """Getting profiles"""

class PoemReader(ProfileReader):

    def __init__(self):
        self.poemFile = '/etc/ar-sync/poem.conf'
        self.poemProfileFile = '/etc/ar-sync/poem-profile.conf'
        self.poemServerFile = '/etc/ar-sync/poem-server.conf'
        self.poemRequest = '%s/myegi/sam-pi/metrics_in_profiles?vo_name=%s&output=json'
        self.hostKey = '/etc/grid-security/hostkey.pem'
        self.hostCert = '/etc/grid-security/hostcert.pem'

    def loadConfiguration(self, configFields):
        if 'poemFile' in configFields:
            self.poemFile = configFields['poemFile']
        if 'poemProfileFile' in configFields:
            self.poemProfileFile = configFields['poemProfileFile']
        if 'poemServerFile' in configFields:
            self.poemServerFile = configFields['poemServerFile']
        if 'poemRequest' in configFields:
            self.poemRequest = configFields['poemRequest']
        if 'hostKey' in configFields:
             self.hostKey = configFields['hostKey']
        if 'hostCert' in configFields:
             self.hostCert = configFields['hostCert']

    def getProfiles(self):

        filteredProfiles = self.loadFilteredProfiles()
        availableVOs = self.loadAvailableVOs()
        poems = self.loadPoems()
        validProfiles = self.loadValidProfiles(poems, filteredProfiles)

        poemServerFile = open(self.poemServerFile, 'r')
        poemServers = poemServerFile.read().splitlines()
        poemServerFile.close();

        #pp = pprint.PrettyPrinter(indent=4)
        #sys.stdout.write("fp:  " + pp.pformat(filteredProfiles) + '\n\n')
        #sys.stdout.write("av:  " + pp.pformat(availableVOs) + '\n\n')
        #sys.stdout.write("po:  " + pp.pformat(poems) + '\n\n')
        #sys.stdout.write("vp:  " + pp.pformat(validProfiles) + '\n\n')
        #sys.stdout.flush()

        profileList = list()
        for line in poemServers:
            if len(line) == 0 or line[0] == '#':
                continue

            if line.split('=')[0] == 'URL':

                url = ''
                defaultProfiles = []
                if len(line.split('=')[1].split(';')) > 1:
                    url = line.split('=')[1].split(';')[0]
                    defaultProfiles = line.split('=')[1].split(';')[1].split(',')
                else:
                    url = line.split('=')[1]

                profiles = line.split('=')[1].split(';')[1]

                urlFile = urllib.urlopen(url)
                urlLines = urlFile.read().splitlines()

                for urlLine in urlLines:
                    if len(urlLine) == 0 or urlLine[0] == '#':
                        continue

                    ngis = urlLine.split(':')[0].split(',')
                    servers = urlLine.split(':')[2].split(',')

                    for vo in availableVOs:
                        serverProfiles = []
                        if len(defaultProfiles) > 0:
                            serverProfiles = defaultProfiles
                        else:
                            serverProfiles = self.loadProfilesFromServer(servers[0], vo, filteredProfiles).keys()
                        for profile in serverProfiles:
                            if profile.upper() in validProfiles.keys():
                                for ngi in ngis:
                                    for server in servers:
                                        profileList.extend(self.createProfileEntries(server, ngi, validProfiles[profile.upper()]))

                urlFile.close();

            else:
                ngis = line.split(':')[0].split(',')
                servers = []

                defaultProfiles = []
                if len(line.split(':')[1].split(';')) > 1:
                    servers = line.split(':')[1].split(';')[0].split(',')
                    defaultProfiles = line.split(':')[1].split(';')[1].split(',')
                else:
                    servers = line.split(':')[1].split(';')[0].split(',')

                for vo in availableVOs:
                    serverProfiles = []
                    if len(defaultProfiles) > 0:
                        serverProfiles = defaultProfiles
                    else:
                        serverProfiles = self.loadProfilesFromServer(servers[0], vo, filteredProfiles).keys()
                    for profile in serverProfiles:
                        if profile.upper() in validProfiles.keys():
                            for ngi in ngis:
                                for server in servers:
                                    profileList.extend(self.createProfileEntries(server, ngi, validProfiles[profile.upper()]))

        return profileList

    def loadFilteredProfiles(self):

        poemProfileFile = open(self.poemProfileFile, 'r')
        poemProfiles = poemProfileFile.read().splitlines()
        poemProfileFile.close();

        filterProfiles = []
        for line in poemProfiles:
            if len(line) == 0 or line[0] == '#':
                continue
            filterProfiles.append(line.upper());

        return filterProfiles

    def loadAvailableVOs(self):

        poemFile = open(self.poemFile, 'r')
        poems = poemFile.read().splitlines()
        poemFile.close();

        avaliableVOs = []
        for line in poems:
            if len(line) == 0 or line[0] == '#':
                continue

            url = line.split(';')[0]
            vos = line.split(';')[1].split(',')

            for vo in vos:
                if not vo in avaliableVOs:
                    avaliableVOs.append(vo)

        return avaliableVOs

    def loadPoems(self):
        poemFile = open(self.poemFile, 'r')
        poems = poemFile.read().splitlines()
        poemFile.close();
        return poems;

    def loadValidProfiles(self, poems, filteredProfiles):
        validProfiles = dict()

        for line in poems:
            if len(line) == 0 or line[0] == '#':
                continue

            url = line.split(';')[0]
            vos = line.split(';')[1].split(',')

            for vo in vos:
                serverProfiles = self.loadProfilesFromServer(url, vo, filteredProfiles)
                for profile in serverProfiles.keys():
                    if not profile in validProfiles.keys():
                        validProfiles[profile] = serverProfiles[profile]
                        validProfiles[profile]['vo'] = vo

        return validProfiles

    def loadProfilesFromServer(self, server, vo, filterProfiles):

        validProfiles = dict()

        doFilterProfiles = False
        if len(filterProfiles) > 0:
            doFilterProfiles = True

        print server
        print self.poemRequest % ('',vo)

        url = resolve_http_redirect('https://' + self.poemRequest % (server,vo), self.hostKey, self.hostCert)
        print url

        o = urlparse.urlparse(url,allow_fragments=True)
        try:
            conn = httplib.HTTPSConnection(o.netloc, 443, self.hostKey, self.hostCert)
            conn.request('GET', o.path + '?' + o.query)

            #conn = httplib.HTTPSConnection(server, 443, hostKey, hostCert)
            #conn.request('GET', defaultPoemRequest % ('',vo))
            res = conn.getresponse()
            if res.status == 200:
                json_data = json.loads(res.read())
                for profile in json_data[0]['profiles']:
                    if not doFilterProfiles or (profile['namespace']+'.'+profile['name']).upper() in filterProfiles:
                        validProfiles[(profile['namespace']+'.'+profile['name']).upper()] = profile
            elif res.status in (301,302):
                print('Redirect: ' + urlparse.urljoin(url, res.getheader('location', '')))

                        # url = urlparse.urljoin(url, responseOb.getheader('location', ''))
                        # conn = self.getconnection(url,True)
            else:
                print('ERROR: Connection failed: ' + res.reason)
        except:
            print "Unexpected error:", sys.exc_info()[0]

        return validProfiles

    def createProfileEntries(self, server, ngi, profile):
        entries = list()
        for metric in profile['metrics']:
            entry = dict()
            entry["profile"] = profile['namespace']+'.'+profile['name']
            entry["service"] = metric['service_flavour']
            entry["metric"] = metric['name']
            entry["server"] = server
            entry["ngi"] = ngi
            entry["vo"] = profile['vo']
            entry["fqan"] = metric['fqan']
            entries.append(entry)
        return entries

##############################
# Writers
##############################
class ProfileWriter(object):

    def loadConfiguration(self, configFields):
        """Loading config"""

    def writeProfiles(self, profiles, date):
        """Writting downtimes"""

class FileWritter(ProfileWriter):

    def __init__(self):
        self.outputDir = '/var/lib/ar-sync'
        self.outputFileTemplate = 'poem_sync_%s.out'
        self.outputFileFormat = '%s\001%s\001%s\001%s\001%s\001%s\001%s\r\n'

    def loadConfiguration(self, configFields):
        if 'outputDir' in configFields:
             self.outputDir = configFields['outputDir']
        if 'outputFileTemplate' in configFields:
             self.outputFileTemplate = configFields['outputFileTemplate']
        if 'outputFileFormat' in configFields:
             self.outputFileFormat = configFields['outputFileFormat']

    def writeProfiles(self, profiles, date):
        filename = createOutputFilename(self.outputDir, self.outputFileTemplate, date)
        outFile = open(filename, 'w')
        for p in profiles:
            outFile.write(self.outputFileFormat % ( p['server'],
                       p['ngi'],
                       p['profile'],
                       p['service'],
                       p['metric'],
                       p['vo'],
                       p['fqan']))
        outFile.close();

class AvroWritter(ProfileWriter):

    def __init__(self):
        self.avroOutputDir = '/var/lib/ar-sync'
        self.avroOutputFileTemplate = 'poem_sync_%s.avro'
        self.avroOutputSchema = '/etc/ar-sync/metric_profiles.avsc'

    def loadConfiguration(self, configFields):
        if 'avroOutputDir' in configFields:
             self.avroOutputDir = configFields['avroOutputDir']
        if 'avroOutputFileTemplate' in configFields:
             self.avroOutputFileTemplate = configFields['avroOutputFileTemplate']
        if 'avroOutputSchema' in configFields:
             self.avroOutputSchema = configFields['avroOutputSchema']

    def writeProfiles(self, profiles, date):
        filename = createOutputFilename(self.avroOutputDir, self.avroOutputFileTemplate, date)

        schema = avro.schema.parse(open(self.avroOutputSchema).read())
        avroFile = open(filename, 'w+')
        writer = DataFileWriter(avroFile, DatumWriter(), schema)

        for p in profiles:
            pt = dict()
            pt['metric'] = p['metric']
            pt['profile'] = p['profile']
            pt['service'] = p['service']
            pt['tags'] = {'vo' : p['vo'], 'fqan' : p['fqan']}
            writer.append(pt)

        writer.close()
        avroFile.close()

    def writeProfilesForCustomers(self, customers, customersdir, profiles, date):
        schema = avro.schema.parse(open(self.avroOutputSchema).read())

        for cust in customers:
            for name, jobs in cust.items():
                for job in jobs:
                    try:
                        outdir = "%s/%s/%s" % (customersdir,\
                                                name.split('_')[1],\
                                                job.keys()[0].split('_')[1])
                        os.makedirs(outdir)
                    except OSError:
                        pass

                    filename = createOutputFilename(outdir, self.avroOutputFileTemplate, date)
                    avroFile = open(filename, 'w+')
                    writer = DataFileWriter(avroFile, DatumWriter(), schema)
                    custprofiles = [profile for (key, value) in job.items() for profile in value['PROFILE']]

                    for p in profiles:
                        if p['profile'].split('.')[-1] in custprofiles:
                            pt = dict()
                            pt['metric'] = p['metric']
                            pt['profile'] = p['profile']
                            pt['service'] = p['service']
                            pt['tags'] = {'vo' : p['vo'], 'fqan' : p['fqan']}
                            writer.append(pt)

                    writer.close()
                    avroFile.close()

##############################
# main
##############################

# date
date = datetime.datetime.utcnow().strftime('%Y_%m_%d')

# load config
config = loadConfiguration()
customers, customersdir = loadCustomerConfiguration()

# read profiles
profiles = list()
for reader in readers:
    if reader == 'poem':
        readerInstance = PoemReader()
        readerInstance.loadConfiguration(config)
        ps = readerInstance.getProfiles()
        profiles.extend(ps)

# write profiles
for writer in writers:
    if writer == 'file':
        writerInstance = FileWritter()
        writerInstance.loadConfiguration(config)
        writerInstance.writeProfiles(profiles, date)
    elif writer == 'avro':
        writerInstance = AvroWritter()
        writerInstance.loadConfiguration(config)
        writerInstance.writeProfiles(profiles, date)
        if customers:
            writerInstance.writeProfilesForCustomers(customers, customersdir, profiles, date)
