#!/usr/bin/python

# Copyright (c) 2013 GRNET S.A., SRCE, IN2P3 CNRS Computing Centre
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the
# License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#
# The views and conclusions contained in the software and
# documentation are those of the authors and should not be
# interpreted as representing official policies, either expressed
# or implied, of either GRNET S.A., SRCE or IN2P3 CNRS Computing
# Centre
#
# The work represented by this source file is partially funded by
# the EGI-InSPIRE project through the European Commission's 7th
# Framework Programme (contract # INFSO-RI-261323)

import urllib
import os
import datetime
import xml.dom.minidom
import httplib
import ConfigParser
import sys
from operator import itemgetter

import avro.schema
from avro.datafile import DataFileWriter
from avro.io import DatumWriter

defaultConfig = '/etc/ar-sync/topology-sync.conf'

SelectGG = dict()
SelectGE = dict()
FetchType = ''

readers = ['gocdb']
writers = ['file', 'avro']

##############################
# create output filename
##############################
def createOutputFilename(directory, fileTemplate, timestamp):
    return directory + '/' + (fileTemplate % timestamp)


##############################
# load config
##############################
def loadConfiguration(configfile):
    #load config
    configFile = None
    configFields = dict()
    try:
        config = ConfigParser.ConfigParser()
        config.read(configfile)

        for section in config.sections():
            if section == 'SelectGroupOfGroups':
                for option in ['Certification', 'Infrastructure', 'Scope', 'Monitored']:
                    if config.has_option(section, option):
                        SelectGG.update({option : config.get(section, option).strip()})
            elif section == 'FetchType':
                for option in ['Sites', 'ServiceGroups']:
                    if config.has_option(section, option):
                        if config.get(section, option):
                            global FetchType
                            FetchType = option
            elif section == 'SelectGroupOfServiceEndpoints':
                for option in ['Production', 'Monitored', 'Scope']:
                    if config.has_option(section, option):
                        SelectGE.update({option : config.get(section, option).strip()})
            elif section == 'OutputDir':
                for option in ['outputDir', 'avroOutputDir']:
                    if config.has_option(section, option):
                        configFields.update({option : config.get(section, option).strip()})
            elif section == "AvroSchemas":
                for option in ['avroOutputGroupOfServicesSchema', 'avroOutputGroupOfGroupsSchema', \
                               'avroOutputGroupOfEndpointsSchema']:
                    if config.has_option(section, option):
                        configFields.update({option : config.get(section, option).strip()})
            elif section == 'HostCertificate':
                for option in ['hostKey', 'hostCert']:
                    if config.has_option(section, option):
                        configFields.update({option : config.get(section, option).strip()})

    except ConfigParser.MissingSectionHeaderError as e:
        print e.filename + " is not a valid configuration file"
        print e.message
        sys.exit(1)

    return configFields

##############################
# Readers
##############################

class TopologyReader(object):

    def loadConfiguration(self, configFields):
        """Loading config"""

    def getGroups(self):
        """Getting groups"""

    def getSites(self):
        """Getting groups"""

class GOCDBReader(TopologyReader):

    def __init__(self):
        self.gocdbHost = 'goc.egi.eu'
        self.gocdbUrl = 'https://' + self.gocdbHost + '/gocdbpi/'
        self.hostKey = '/etc/grid-security/hostkey.pem'
        self.hostCert = '/etc/grid-security/hostcert.pem'

        self.siteList = dict()
        self.serviceList = dict()
        self.groupList = dict()

    def loadConfiguration(self, configFields):
        if 'gocdbHost' in configFields:
             self.gocdbHost = configFields['gocdbHost']
        if 'gocdbUrl' in configFields:
             self.gocdbUrl = configFields['gocdbUrl']
        if 'hostKey' in configFields:
             self.hostKey = configFields['hostKey']
        if 'hostCert' in configFields:
             self.hostCert = configFields['hostCert']

    def getGroupOfServices(self):
        self.loadDataIfNeeded()

        groups = list()
        for key, group in self.groupList.iteritems():
            for service in group['services']:

                g = dict()
                g['type'] = FetchType.upper()
                g['group'] = group['name']
                g['service'] = service['type']
                g['hostname'] = service['hostname']
                g['group_monitored'] = group['monitored']
                g['tags'] = {'scope' : group['scope'], \
                            'monitored' : 1 if service['monitored'] == "Y" else 0, \
                            'production' : 1 if service['production'] == "Y" else 0}
                groups.append(g)

        return groups

    def getSites(self):
        self.loadDataIfNeeded()

        sortedSrvices = sorted(self.serviceList.iteritems(), key=lambda (x, y): y['sortId'])

        sites = list()
        lastId = ''
        for key, service in sortedSrvices:
            if service['site'] in self.siteList:
                site = self.siteList[service['site']]

                if lastId != service['sortId']:

                    s = dict()
                    s['hostname'] = service['hostname']
                    s['service'] = service['type']
                    s['production'] = service['production']
                    s['monitored'] = service['monitored']
                    s['scope'] = service['scope']
                    s['site'] = service['site']
                    s['roc'] = service['roc']
                    s['infrastructure'] = site['infrastructure']
                    s['certification'] = site['certification']
                    s['site_scope'] = site['scope']

                    sites.append(s)

                lastId = service['sortId']
            else:
                print('ERROR: found service endpoint (%s, %s) associated to non-existing site %s' % (service['hostname'], service['type'], service['site']))

        return sites

    def getGroupOfGroups(self):
        self.loadDataIfNeeded()

        groupofgroups = list()

        if FetchType == "ServiceGroups":
            for key, value in self.groupList.iteritems():
                g = dict()
                g['type'] = 'PROJECT'
                g['group'] = 'EGI'
                g['subgroup'] = value['name']
                g['tags'] = {'monitored' : 1 if value['monitored'] == "Y" else 0, \
                            'scope' : value['scope']}
                groupofgroups.append(g)
        else:
            gg = sorted([value for key, value in self.siteList.iteritems()], \
                                    key=lambda s: s['ngi'])

            for gr in gg:
                g = dict()
                g['type'] = 'NGI'
                g['group'] = gr['ngi']
                g['subgroup'] = gr['site']
                g['tags'] = {'certification' : gr['certification'], \
                            'scope' : gr['scope'], \
                            'infrastructure' : gr['infrastructure']}
                groupofgroups.append(g)

        return groupofgroups

    def getGroupOfEndpoints(self):
        self.loadDataIfNeeded()

        groupofendpoints = list()
        ge = sorted([value for key, value in self.serviceList.iteritems()], \
                                 key=lambda s: s['site'])

        for gr in ge:
            g = dict()
            g['type'] = FetchType.upper()
            g['group'] = gr['site']
            g['service'] = gr['type']
            g['hostname'] = gr['hostname']
            g['tags'] = {'scope' : gr['scope'], \
                         'monitored' : 1 if gr['monitored'] == "Y" else 0, \
                         'production' : 1 if gr['production'] == "Y" else 0}
            groupofendpoints.append(g)

        return groupofendpoints

    def loadDataIfNeeded(self):
        if len(self.siteList) == 0:
            self.getSitesInternal(self.siteList, 'EGI')
            self.getSitesInternal(self.siteList, 'Local')

        if len(self.serviceList) == 0:
            self.getServiceEndpoints(self.serviceList, 'EGI')
            self.getServiceEndpoints(self.serviceList, 'Local')

        if len(self.groupList) == 0:
            self.getServiceGroups(self.groupList, 'EGI')
            self.getServiceGroups(self.groupList, 'Local')

    def getServiceEndpoints(self, serviceList, scope):
        urlFile = urllib.urlopen(self.gocdbUrl + '/public/?method=get_service_endpoint&scope=' + scope)
        doc = xml.dom.minidom.parse(urlFile)
        services = doc.getElementsByTagName('SERVICE_ENDPOINT')
        for service in services:
            serviceId = ''
            if service.getAttributeNode('PRIMARY_KEY'):
                serviceId = str(service.attributes['PRIMARY_KEY'].value)
            if serviceId not in serviceList:
                serviceList[serviceId] = {}
            serviceList[serviceId]['hostname'] = service.getElementsByTagName('HOSTNAME')[0].childNodes[0].data
            serviceList[serviceId]['type'] = service.getElementsByTagName('SERVICE_TYPE')[0].childNodes[0].data
            serviceList[serviceId]['monitored'] = service.getElementsByTagName('NODE_MONITORED')[0].childNodes[0].data
            serviceList[serviceId]['production'] = service.getElementsByTagName('IN_PRODUCTION')[0].childNodes[0].data
            serviceList[serviceId]['site'] = service.getElementsByTagName('SITENAME')[0].childNodes[0].data
            serviceList[serviceId]['roc'] = service.getElementsByTagName('ROC_NAME')[0].childNodes[0].data
            serviceList[serviceId]['scope'] = scope
            serviceList[serviceId]['sortId'] = serviceList[serviceId]['hostname'] + '-' + serviceList[serviceId]['type'] + '-' + serviceList[serviceId]['site']
        urlFile.close();

    def getSitesInternal(self, siteList, scope):
        conn = httplib.HTTPSConnection(self.gocdbHost, 443, self.hostKey, self.hostCert)
        conn.request('GET', '/gocdbpi/private/?method=get_site&scope=' + scope)
        res = conn.getresponse()
        if res.status == 200:
            dom = xml.dom.minidom.parseString(res.read())
            sites = dom.getElementsByTagName('SITE')
            for site in sites:
                siteName = site.getAttribute('NAME')
                if siteName not in siteList:
                    siteList[siteName] = {'site': siteName}
                siteList[siteName]['infrastructure'] = site.getElementsByTagName('PRODUCTION_INFRASTRUCTURE')[0].childNodes[0].data
                siteList[siteName]['certification'] = site.getElementsByTagName('CERTIFICATION_STATUS')[0].childNodes[0].data
                siteList[siteName]['ngi'] = site.getElementsByTagName('ROC')[0].childNodes[0].data
                siteList[siteName]['scope'] = scope
        else:
            print('ERROR: Connection to GOCDB failed: ' + res.reason)

    def getServiceGroups(self, groupList, scope):
        conn = httplib.HTTPSConnection(self.gocdbHost, 443, self.hostKey, self.hostCert)
        conn.request('GET', '/gocdbpi/private/?method=get_service_group&scope=' + scope)
        res = conn.getresponse()
        if res.status == 200:
            doc = xml.dom.minidom.parseString(res.read())
            groups = doc.getElementsByTagName('SERVICE_GROUP')
            for group in groups:
                groupId = group.getAttribute('PRIMARY_KEY')
                if groupId not in groupList:
                    groupList[groupId] = {}
                groupList[groupId]['name'] = group.getElementsByTagName('NAME')[0].childNodes[0].data
                groupList[groupId]['monitored'] = group.getElementsByTagName('MONITORED')[0].childNodes[0].data
                groupList[groupId]['scope'] = scope
                groupList[groupId]['services'] = []
                services = group.getElementsByTagName('SERVICE_ENDPOINT')
                for service in services:
                    serviceDict = {}
                    serviceDict['hostname'] = service.getElementsByTagName('HOSTNAME')[0].childNodes[0].data
                    serviceDict['type'] = service.getElementsByTagName('SERVICE_TYPE')[0].childNodes[0].data
                    serviceDict['monitored'] = service.getElementsByTagName('NODE_MONITORED')[0].childNodes[0].data
                    serviceDict['production'] = service.getElementsByTagName('IN_PRODUCTION')[0].childNodes[0].data
                    groupList[groupId]['services'].append(serviceDict)
        else:
            print('ERROR: Connection to GOCDB failed: ' + res.reason)

##############################
# Writers
##############################
class TopologyWriter(object):

    def loadConfiguration(self, configFields):
        """Loading config"""

    def writeGroups(self, groups, date):
        """Writting groups"""

    def writeGroupOfServices(self, groups, date):
        """Writting group of services"""

    def writeGroupOfGroups(self, groupofgroups, date):
        """Writing groups of groups"""

    def writeGroupOfEndpoints(self, groupofendpoints, date):
        """Writing group of endpoints"""

    def writeSites(self, sites, date):
        """Writting sites"""

class FileWritter(TopologyWriter):

    def __init__(self):
        self.outputDir = '/var/lib/ar-sync'

        self.outputGroupFileTemplate = '/groups_%s.out'
        # Hostname, Service Type, Production, Monitored, Service group, Group Monitored, Group Scope
        self.outputGroupFileFormat = '%s\001%s\001%s\001%s\001%s\001%s\001%s\r\n'

        self.outputSiteFileTemplate = '/sites_%s.out'
        # Hostname, Service Type, Production, Monitored, Scope, Site, NGI, Infrastructure, Certification Status, Site Scope
        self.outputSiteFileFormat = '%s\001%s\001%s\001%s\001%s\001%s\001%s\001%s\001%s\001%s\r\n'

    def loadConfiguration(self, configFields):
        if 'outputDir' in configFields:
             self.outputDir = configFields['outputDir']
        if 'outputGroupFileTemplate' in configFields:
             self.outputGroupFileTemplate = configFields['outputGroupFileTemplate']
        if 'outputGroupFileFormat' in configFields:
             self.outputGroupFileFormat = configFields['outputGroupFileFormat']
        if 'outputSiteFileTemplate' in configFields:
             self.outputSiteFileTemplate = configFields['outputSiteFileTemplate']
        if 'outputGroupFileFormat' in configFields:
             self.outputSiteFileFormat = configFields['outputSiteFileFormat']

    def writeGroups(self, groups, date):
        filename = createOutputFilename(self.outputDir, self.outputGroupFileTemplate, date)
        outFile = open(filename, 'w')
        for g in groups:
            outFile.write(self.outputGroupFileFormat % ( g['hostname'],
                       g['service'],
                       g['tags']['production'],
                       g['tags']['monitored'],
                       g['group'],
                       g['group_monitored'],
                       g['tags']['scope']))
        outFile.close()

    def writeSites(self, sites, date):
        filename = createOutputFilename(self.outputDir, self.outputSiteFileTemplate, date)
        outFile = open(filename, 'w')
        for s in sites:
            outFile.write(self.outputSiteFileFormat % ( s['hostname'],
                       s['service'],
                       s['production'],
                       s['monitored'],
                       s['scope'],
                       s['site'],
                       s['roc'],
                       s['infrastructure'],
                       s['certification'],
                       s['site_scope']))
        outFile.close();

class AvroWritter(TopologyWriter):

    def __init__(self):
        self.avroOutputDir = '/var/lib/ar-sync'
        self.avroOutputGroupOfGroupsFileTemplate = 'group_groups_%s.avro'
        self.avroOutputGroupOfGroupsSchema = '/etc/ar-sync/group_groups.avsc'
        self.avroOutputGroupOfServicesSchema = '/etc/ar-sync/group_services.avsc'
        self.avroOutputGroupOfEndpointsFileTemplate = 'group_endpoints_%s.avro'
        self.avroOutputGroupOfEndpointsSchema = '/etc/ar-sync/group_endpoints.avsc'

    def loadConfiguration(self, configFields):
        if 'avroOutputDir' in configFields:
             self.avroOutputDir = configFields['avroOutputDir']
        if 'avroOutputGroupOfGroupsSchema' in configFields:
             self.avroOutputGroupOfGroupsSchema = configFields['avroOutputGroupOfGroupsSchema']
        if 'avroOutputGroupOfServicesSchema' in configFields:
             self.avroOutputGroupOfServicesSchema = configFields['avroOutputGroupOfServicesSchema']
        if 'avroOutputGroupOfEndpointsSchema' in configFields:
             self.avroOutputGroupOfEndpointsSchema = configFields['avroOutputGroupOfEndpointsSchema']

    def FilterByTags(self, tags, listofelem):
        for attr in tags.keys():
            def getit(elem):
                value = elem['tags'][attr.lower()]
                if isinstance(value, int):
                    value = "Y" if value else "N"
                if value.lower() == tags[attr].lower():
                    return True
            listofelem = filter(getit, listofelem)
        return listofelem

    def writeGroupOfGroups(self, groupofgroups, date):
        if FetchType == "ServiceGroups":
            schema = avro.schema.parse(open(self.avroOutputGroupOfServicesSchema).read())
        else:
            schema = avro.schema.parse(open(self.avroOutputGroupOfGroupsSchema).read())

        filename = createOutputFilename(self.avroOutputDir, self.avroOutputGroupOfGroupsFileTemplate, date)
        avroFile = open(filename, 'w+')
        writer = DataFileWriter(avroFile, DatumWriter(), schema)

        groupofgroups = self.FilterByTags(SelectGG, groupofgroups)

        for gg in groupofgroups:
            writer.append(gg)

        writer.close()
        avroFile.close()

    def writeGroupOfEndpoints(self, groupofendpoints, date):
        filename = createOutputFilename(self.avroOutputDir, self.avroOutputGroupOfEndpointsFileTemplate, date)

        schema = avro.schema.parse(open(self.avroOutputGroupOfEndpointsSchema).read())
        avroFile = open(filename, 'w+')
        writer = DataFileWriter(avroFile, DatumWriter(), schema)

        groupofendpoints = self.FilterByTags(SelectGE, groupofendpoints)

        for g in groupofendpoints:
            writer.append(g)

        writer.close()
        avroFile.close()


##############################
# main
##############################

# date
date = datetime.datetime.utcnow().strftime('%Y_%m_%d')

# load configuration
if len(sys.argv) > 1:
    config = loadConfiguration(sys.argv[1])
else:
    config = loadConfiguration(defaultConfig)

# read downtimes
groupofservices = list()
sites = list()
groupofgroups = list()
groupofendpoints = list()
for reader in readers:
    if reader == 'gocdb':
        readerInstance = GOCDBReader()
        readerInstance.loadConfiguration(config)
        ss = readerInstance.getSites()
        gs = readerInstance.getGroupOfServices()
        gg = readerInstance.getGroupOfGroups()
        ge = readerInstance.getGroupOfEndpoints()
        sites.extend(ss)
        groupofservices.extend(gs)
        groupofgroups.extend(gg)
        groupofendpoints.extend(ge)

# write downtimes
for writer in writers:
    if writer == 'file':
        writerInstance = FileWritter()
        writerInstance.loadConfiguration(config)
        writerInstance.writeSites(sites, date)
        writerInstance.writeGroups(groupofservices, date)
    elif writer == 'avro':
        writerInstance = AvroWritter()
        writerInstance.loadConfiguration(config)
        if FetchType == "ServiceGroups":
            writerInstance.writeGroupOfEndpoints(groupofservices, date)
        else:
            writerInstance.writeGroupOfEndpoints(groupofendpoints, date)
        writerInstance.writeGroupOfGroups(groupofgroups, date)
